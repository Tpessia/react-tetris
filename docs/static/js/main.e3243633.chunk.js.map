{"version":3,"sources":["assets/tetris.mp3","utils/getRandomInt.ts","components/GameCanvas/configs.ts","components/Shapes/BaseShape.ts","components/Shapes/ShapeTypes/ShapeLeftL.ts","components/Shapes/ShapeTypes/ShapeLeftS.ts","components/Shapes/ShapeTypes/ShapeLine.ts","components/Shapes/ShapeTypes/ShapeRightL.ts","components/Shapes/ShapeTypes/ShapeRightS.ts","components/Shapes/ShapeTypes/ShapeSquare.ts","components/Shapes/ShapeTypes/ShapeT.ts","components/GameCanvas/GameCanvasStyles.ts","components/GameCanvas/GameCanvas.tsx","components/Shapes/shapeBuilder.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","getRandomInt","min","max","Math","ceil","floor","random","configs","container","width","height","canvas","backgroundColor","patternBG","patternInnerBG","patternStroke","patternWidth","gridWidth","gridHeight","pixel","offset","widthT","heightT","strokeColor","strokeWidth","Rotation","rotations","Object","values","filter","e","BaseShape","draw","rotationShapes","nested","pixels","rotation","offsetX","this","offsetY","matrix","create","i","j","label","rect","x","y","push","length","render","fill","stroke","color","Left","Up","shape","gap","hasValue","bbox","widthGap","widthStartGap","heightGap","heightStartGap","ShapeLeftL","Right","Bottom","ShapeLeftS","ShapeLine","ShapeRightL","ShapeRightS","ShapeSquare","ShapeT","CanvasWrapper","styled","div","CanvasControls","CanvasScore","Canvas","tetrisAudio","require","GameCanvas","useState","ref","setRef","score","paused","ended","game","setGame","grid","useRef","setDraw","shapes","available","count","tick","setTick","audioRef","togglePlay","play","pause","getPositions","parentPosition","children","map","s","checkColission","useCallback","direction","delta","collision","positions","pos","current","deltaCrash","calcDeltaCrash","realStartHeight","fixPosition","realStartWidth","useEffect","tempDraw","SVG","size","pattern","add","addTo","startup","newShapes","newGrid","active","find","some","p","cloneDeep","index","indexOf","update","$set","undefined","build","shapeBuilder","rndX","createNewShape","fullLines","reduce","acc","val","reverse","lineCount","remove","forEach","round","pow","tickTime","setTimeout","runActive","run","handlers","MOVE_UP","event","rotate","MOVE_DOWN","h","MOVE_LEFT","nextPos","MOVE_RIGHT","SPACE","allowChanges","keyMap","src","autoPlay","loop","onClick","App","Boolean","window","location","hostname","match","configure","ignoreRepeatedEventsWhenKeyHeldDown","ReactDOM","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e3243633.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/tetris.37fb910f.mp3\";","export default function getRandomInt(min: number, max: number) { // min, max inclusive\r\n    min = Math.ceil(min)\r\n    max = Math.floor(max)\r\n    return Math.floor(Math.random() * (max - min + 1)) + min\r\n}","const configs = {\r\n    container: {\r\n        width: -1,\r\n        height: -1\r\n    },\r\n    canvas: {\r\n        width: -1,\r\n        height: -1,\r\n        backgroundColor: 'transparent',\r\n        patternBG: '#44444433',\r\n        patternInnerBG: '#55555533',\r\n        patternStroke: '#11111133',\r\n        patternWidth: 1,\r\n        gridWidth: 15,\r\n        gridHeight: 30\r\n    },\r\n    pixel: {\r\n        offset: -1,\r\n        widthT: -1,\r\n        heightT: -1,\r\n        width: 10,\r\n        height: 10,\r\n        backgroundColor: '#888',\r\n        strokeColor: '#555',\r\n        strokeWidth: 3\r\n    }\r\n}\r\n\r\nconfigs.pixel.offset = configs.pixel.strokeWidth / 2\r\n\r\nconfigs.pixel.widthT = configs.pixel.width + configs.pixel.strokeWidth\r\nconfigs.pixel.heightT = configs.pixel.height + configs.pixel.strokeWidth\r\n\r\nconfigs.canvas.width = configs.pixel.widthT * configs.canvas.gridWidth\r\nconfigs.canvas.height = configs.pixel.heightT * configs.canvas.gridHeight\r\n\r\nconfigs.container.width = configs.canvas.width\r\nconfigs.container.height = configs.canvas.height\r\n\r\nexport default configs;","import { Rect, Svg } from '@svgdotjs/svg.js';\r\nimport { EnumDictionaryStrict } from '../../models/Dictionary';\r\nimport configs from '../GameCanvas/configs';\r\nimport getRandomInt from '../../utils/getRandomInt';\r\n\r\nexport enum Rotation {\r\n    Up,\r\n    Right,\r\n    Bottom,\r\n    Left\r\n}\r\n\r\nexport type RotationShape = number[][]\r\nexport type RotationShapes = EnumDictionaryStrict<Rotation, RotationShape>\r\n\r\nconst rotations = Object.values(Rotation).filter(e => typeof(e) === 'number') as Rotation[]\r\n\r\nexport default abstract class BaseShape {\r\n    abstract rotationShapes: RotationShapes\r\n\r\n    nested: Svg\r\n    pixels: Rect[] = []\r\n\r\n    rotation: Rotation = 0\r\n\r\n    offset = configs.pixel.offset\r\n    strokeWidth = configs.pixel.strokeWidth\r\n    strokeColor = configs.pixel.strokeColor\r\n    width = configs.pixel.width\r\n    height = configs.pixel.height\r\n    widthT = configs.pixel.widthT\r\n    heightT = configs.pixel.heightT\r\n    offsetX = this.width + this.strokeWidth\r\n    offsetY = this.height + this.strokeWidth\r\n\r\n    constructor(draw: Svg) {\r\n        this.nested = draw.nested()\r\n    }\r\n\r\n    get widthGap() {\r\n        const shape = this.rotationShapes[this.rotation]\r\n        let gap = 0\r\n\r\n        for (let i in shape[0]) {\r\n            let hasValue = false\r\n            \r\n            for (let j in shape) {\r\n                if (shape[j][i] !== 0)\r\n                    hasValue = true\r\n            }\r\n\r\n            if (!hasValue) gap++ \r\n        }\r\n        \r\n        return gap\r\n    }\r\n\r\n    get widthStartGap() {\r\n        const shape = this.rotationShapes[this.rotation]\r\n        let gap = 0\r\n\r\n        for (let i in shape[0]) {\r\n            let hasValue = false\r\n            \r\n            for (let j in shape) {\r\n                if (shape[j][i] !== 0)\r\n                    hasValue = true\r\n            }\r\n\r\n            if (!hasValue) gap++\r\n            else break\r\n        }\r\n        \r\n        return gap\r\n    }\r\n\r\n    get heightGap() {\r\n        const shape = this.rotationShapes[this.rotation]\r\n        let gap = 0\r\n\r\n        for (let i in shape) {\r\n            let hasValue = false\r\n            \r\n            for (let j in shape[0]) {\r\n                if (shape[i][j] !== 0)\r\n                    hasValue = true\r\n            }\r\n\r\n            if (!hasValue) gap++\r\n        }\r\n        \r\n        return gap\r\n    }\r\n\r\n    get heightStartGap() {\r\n        const shape = this.rotationShapes[this.rotation]\r\n        let gap = 0\r\n\r\n        for (let i in shape) {\r\n            let hasValue = false\r\n            \r\n            for (let j in shape[0]) {\r\n                if (shape[i][j] !== 0)\r\n                    hasValue = true\r\n            }\r\n\r\n            if (!hasValue) gap++\r\n            else break\r\n        }\r\n        \r\n        return gap\r\n    }\r\n\r\n    get realWidth() {\r\n        return this.nested.bbox().width + this.widthGap * this.widthT\r\n    }\r\n    \r\n    get realStartWidth() {\r\n        return this.nested.bbox().width + this.widthStartGap * this.widthT\r\n    }\r\n\r\n    get realHeight() {\r\n        return this.nested.bbox().height + this.heightGap * this.heightT\r\n    }\r\n    \r\n    get realStartHeight() {\r\n        return this.nested.bbox().height + this.heightStartGap * this.heightT\r\n    }\r\n\r\n    protected render(matrix: RotationShape, create: boolean = false) {\r\n        const pixels: Rect[] = []\r\n        \r\n        for (const i in matrix) {\r\n            for (const j in matrix[i]) {\r\n                const label = matrix[i][j]\r\n                if (label !== 0) {\r\n                    let rect = create ? this.nested.rect(this.width, this.height) : this.pixels[label-1]\r\n                    rect = rect.x(+j * this.offsetX + this.offset).y(+i * this.offsetY + this.offset)\r\n                    pixels.push(rect)\r\n                }\r\n            }\r\n        }\r\n\r\n        return pixels\r\n    }\r\n\r\n    build() {\r\n        this.rotation = rotations[getRandomInt(0,rotations.length - 1)]\r\n\r\n        this.pixels = this.render(this.rotationShapes[this.rotation], true)\r\n\r\n        this.nested\r\n            .fill(configs.pixel.backgroundColor)\r\n            .stroke({ width: this.strokeWidth, color: this.strokeColor })\r\n\r\n        return this\r\n    }\r\n\r\n    rotate() {\r\n        this.rotation = this.rotation === Rotation.Left ? Rotation.Up : this.rotation+1\r\n        this.pixels = this.render(this.rotationShapes[this.rotation])\r\n    }\r\n}","import BaseShape, { Rotation } from '../BaseShape';\r\n\r\nexport default class ShapeLeftL extends BaseShape {\r\n    rotationShapes = {\r\n        [Rotation.Up]: [\r\n            [0,4,0],\r\n            [0,3,0],\r\n            [1,2,0]\r\n        ],\r\n        [Rotation.Right]: [\r\n            [1,0,0],\r\n            [2,3,4],\r\n            [0,0,0]\r\n        ],\r\n        [Rotation.Bottom]: [\r\n            [0,2,1],\r\n            [0,3,0],\r\n            [0,4,0]\r\n        ],\r\n        [Rotation.Left]: [\r\n            [0,0,0],\r\n            [4,3,2],\r\n            [0,0,1]\r\n        ]\r\n    }\r\n}","import BaseShape, { Rotation } from '../BaseShape';\r\n\r\nexport default class ShapeLeftS extends BaseShape {\r\n    rotationShapes = {\r\n        [Rotation.Up]: [\r\n            [0,0,1],\r\n            [0,3,2],\r\n            [0,4,0]\r\n        ],\r\n        [Rotation.Right]: [\r\n            [0,0,0],\r\n            [4,3,0],\r\n            [0,2,1]\r\n        ],\r\n        [Rotation.Bottom]: [\r\n            [0,4,0],\r\n            [2,3,0],\r\n            [1,0,0]\r\n        ],\r\n        [Rotation.Left]: [\r\n            [1,2,0],\r\n            [0,3,4],\r\n            [0,0,0]\r\n        ]\r\n    }\r\n}","import BaseShape, { Rotation } from '../BaseShape';\r\n\r\nexport default class ShapeLine extends BaseShape {\r\n    rotationShapes = {\r\n        [Rotation.Up]: [\r\n            [0,0,1,0],\r\n            [0,0,2,0],\r\n            [0,0,3,0],\r\n            [0,0,4,0]\r\n        ],\r\n        [Rotation.Right]: [\r\n            [0,0,0,0],\r\n            [0,0,0,0],\r\n            [1,2,3,4],\r\n            [0,0,0,0]\r\n        ],\r\n        [Rotation.Bottom]: [\r\n            [0,0,1,0],\r\n            [0,0,2,0],\r\n            [0,0,3,0],\r\n            [0,0,4,0]\r\n        ],\r\n        [Rotation.Left]: [\r\n            [0,0,0,0],\r\n            [0,0,0,0],\r\n            [1,2,3,4],\r\n            [0,0,0,0]\r\n        ]\r\n    }\r\n}","import BaseShape, { Rotation } from '../BaseShape';\r\n\r\nexport default class ShapeRightL extends BaseShape {\r\n    rotationShapes = {\r\n        [Rotation.Up]: [\r\n            [0,4,0],\r\n            [0,3,0],\r\n            [0,2,1]\r\n        ],\r\n        [Rotation.Right]: [\r\n            [0,0,0],\r\n            [2,3,4],\r\n            [1,0,0]\r\n        ],\r\n        [Rotation.Bottom]: [\r\n            [1,2,0],\r\n            [0,3,0],\r\n            [0,4,0]\r\n        ],\r\n        [Rotation.Left]: [\r\n            [0,0,1],\r\n            [4,3,2],\r\n            [0,0,0]\r\n        ]\r\n    }\r\n}","import BaseShape, { Rotation } from '../BaseShape';\r\n\r\nexport default class ShapeRightS extends BaseShape {\r\n    rotationShapes = {\r\n        [Rotation.Up]: [\r\n            [1,0,0],\r\n            [2,3,0],\r\n            [0,4,0]\r\n        ],\r\n        [Rotation.Right]: [\r\n            [0,2,1],\r\n            [4,3,0],\r\n            [0,0,0]\r\n        ],\r\n        [Rotation.Bottom]: [\r\n            [0,4,0],\r\n            [0,3,2],\r\n            [0,0,1]\r\n        ],\r\n        [Rotation.Left]: [\r\n            [0,0,0],\r\n            [0,3,4],\r\n            [1,2,0]\r\n        ]\r\n    }\r\n}","import BaseShape, { Rotation } from '../BaseShape';\r\n\r\nexport default class ShapeSquare extends BaseShape {\r\n    rotationShapes = {\r\n        [Rotation.Up]: [\r\n            [1,2],\r\n            [3,4]\r\n        ],\r\n        [Rotation.Right]: [\r\n            [3,1],\r\n            [4,2]\r\n        ],\r\n        [Rotation.Bottom]: [\r\n            [4,3],\r\n            [2,1]\r\n        ],\r\n        [Rotation.Left]: [\r\n            [2,4],\r\n            [1,3]\r\n        ]\r\n    }\r\n}","import BaseShape, { Rotation } from '../BaseShape';\r\n\r\nexport default class ShapeT extends BaseShape {\r\n    rotationShapes = {\r\n        [Rotation.Up]: [\r\n            [0,1,0],\r\n            [2,3,4],\r\n            [0,0,0]\r\n        ],\r\n        [Rotation.Right]: [\r\n            [0,2,0],\r\n            [0,3,1],\r\n            [0,4,0]\r\n        ],\r\n        [Rotation.Bottom]: [\r\n            [0,0,0],\r\n            [4,3,2],\r\n            [0,1,0]\r\n        ],\r\n        [Rotation.Left]: [\r\n            [0,4,0],\r\n            [1,3,0],\r\n            [0,2,0]\r\n        ]\r\n    }\r\n}","import styled from 'styled-components';\r\n\r\nexport const CanvasWrapper = styled.div`\r\n    display: flex;\r\n`\r\n\r\nexport const CanvasControls = styled.div`\r\n    margin-left: 10px;\r\n`\r\n\r\nexport const CanvasScore = styled.div`\r\n    \r\n`\r\n\r\nexport const Canvas = styled.div`\r\n    display: flex;\r\n    border: 3px solid #000;\r\n`","import { Rect, SVG, Svg } from '@svgdotjs/svg.js';\r\nimport update from 'immutability-helper';\r\nimport { cloneDeep } from 'lodash-es';\r\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\r\nimport { GlobalHotKeys } from \"react-hotkeys\";\r\nimport getRandomInt from '../../utils/getRandomInt';\r\nimport BaseShape from '../Shapes/BaseShape';\r\nimport shapeBuilder, { ShapeClass } from '../Shapes/shapeBuilder';\r\nimport ShapeLeftL from '../Shapes/ShapeTypes/ShapeLeftL';\r\nimport ShapeLeftS from '../Shapes/ShapeTypes/ShapeLeftS';\r\nimport ShapeLine from '../Shapes/ShapeTypes/ShapeLine';\r\nimport ShapeRightL from '../Shapes/ShapeTypes/ShapeRightL';\r\nimport ShapeRightS from '../Shapes/ShapeTypes/ShapeRightS';\r\nimport ShapeSquare from '../Shapes/ShapeTypes/ShapeSquare';\r\nimport ShapeT from '../Shapes/ShapeTypes/ShapeT';\r\nimport configs from './configs';\r\nimport './GameCanvas.scss';\r\nimport { MdPause, MdPlayArrow } from 'react-icons/md';\r\nimport { Canvas, CanvasWrapper, CanvasControls, CanvasScore } from './GameCanvasStyles';\r\nconst tetrisAudio = require('../../assets/tetris.mp3');\r\n\r\ntype Grid = ((Rect | undefined)[] | undefined)[]\r\n\r\ninterface Position {\r\n    x: number,\r\n    y: number,\r\n    pixel: Rect\r\n}\r\n\r\ninterface ShapeState {\r\n    shape: BaseShape,\r\n    active: boolean\r\n}\r\n\r\nconst GameCanvas: React.FC = () => {\r\n    const [ref, setRef] = useState<HTMLElement | null>(null)\r\n    const [game, setGame] = useState({ score: 0, paused: false, ended: false })\r\n    const grid = useRef<Grid>([])\r\n    const [draw, setDraw] = useState<Svg | null>(null)\r\n    let shapes = useRef<ShapeState[]>([])\r\n    const [tick, setTick] = useState<{ available: boolean, count: number }>({\r\n        available: true, count: 0\r\n    })\r\n    let audioRef: HTMLAudioElement | null = null\r\n\r\n    const togglePlay = () => {\r\n        if (!game.ended) {\r\n            if (game.paused) audioRef?.play()\r\n            else audioRef?.pause()\r\n\r\n            setGame({ ...game, paused: !game.paused })\r\n        }\r\n    }\r\n\r\n    const getPositions = (shape: BaseShape) => {\r\n        const parentPosition = {\r\n            x: shape.nested.x() / shape.widthT,\r\n            y: shape.nested.y() / shape.heightT\r\n        }\r\n        \r\n        const positions: Position[] = shape.nested.children().map(s => {\r\n            const rect = s as Rect\r\n            const x = (rect.x() - shape.offset) / shape.widthT\r\n            const y = (rect.y() - shape.offset) / shape.heightT\r\n            return {\r\n                x: x + parentPosition.x,\r\n                y: y + parentPosition.y,\r\n                pixel: rect\r\n            }\r\n        })\r\n        \r\n        return positions\r\n    }\r\n\r\n    const checkColission = useCallback((draw: Svg, shape: BaseShape, direction: 'left' | 'down' | 'right', delta: number = 0) => {\r\n        let collision = false\r\n\r\n        let positions = getPositions(shape)\r\n        \r\n        for (let pos of positions) {\r\n            if ((direction === 'down' && !!grid.current[pos.y+1]?.[pos.x]) ||\r\n                (direction === 'left' && !!grid.current[pos.y]?.[pos.x-1]) ||\r\n                (direction === 'right' && !!grid.current[pos.y]?.[pos.x+1])) {\r\n                collision = true\r\n            }\r\n        }\r\n\r\n        const deltaCrash = calcDeltaCrash(draw, shape) - delta\r\n\r\n        return collision || deltaCrash <= 0\r\n    }, [grid])\r\n    \r\n    const calcDeltaCrash = (draw: Svg, shape: BaseShape) => {\r\n        return draw.height() - (shape.nested.y() + shape.strokeWidth + shape.realStartHeight)\r\n    }\r\n\r\n    const fixPosition = useCallback((shape: BaseShape) => {\r\n        if (shape.nested.x() < -shape.widthStartGap * shape.widthT)\r\n            shape.nested.x(shape.widthStartGap * shape.widthT)\r\n        else if (shape.nested.x() + shape.realStartWidth > configs.canvas.width)\r\n            shape.nested.x(configs.canvas.width - shape.realStartWidth - shape.strokeWidth)\r\n        else {\r\n            const y = shape.nested.y()\r\n            shape.nested.y(shape.nested.y() - shape.heightT)\r\n            if (draw && !checkColission(draw, shape, 'down'))\r\n                shape.nested.y(y)\r\n        }\r\n    }, [draw, checkColission])\r\n\r\n    // STARTUP\r\n    useEffect(() => {\r\n        function startup() {\r\n            if (ref && !draw) {\r\n                let tempDraw = SVG().size(configs.container.width, configs.container.height)\r\n    \r\n                const canvas = tempDraw\r\n                    .rect(configs.canvas.width, configs.canvas.height)\r\n                    .fill(configs.canvas.backgroundColor)\r\n\r\n                let pattern = tempDraw.pattern(configs.pixel.widthT, configs.pixel.heightT, add => {\r\n                    add.rect(configs.pixel.widthT, configs.pixel.heightT)\r\n                        .fill(configs.canvas.patternBG)\r\n                    add.rect(configs.pixel.width, configs.pixel.height)\r\n                        .x(configs.pixel.offset).y(configs.pixel.offset)\r\n                        .fill(configs.canvas.patternInnerBG)\r\n                        .stroke({\r\n                            color: configs.canvas.patternStroke,\r\n                            width: configs.canvas.patternWidth\r\n                        })\r\n    \r\n                    // const width = configs.pixel.widthT - 1\r\n                    // const height = configs.pixel.heightT - 1\r\n    \r\n                    // add.line(0, 0, width, 0)\r\n                    //     .stroke({ color: 'red', width: 2 })\r\n                    // add.line(width, 0, width, height)\r\n                    //     .stroke({ color: 'red', width: 2 })\r\n                    // add.line(width, height, 0, height)\r\n                    //     .stroke({ color: 'red', width: 2 })\r\n                    // add.line(0, height, 0, 0)\r\n                    //     .stroke({ color: 'red', width: 2 })\r\n                })\r\n    \r\n                canvas.fill(pattern)\r\n    \r\n                tempDraw.addTo(ref)\r\n    \r\n                setDraw(tempDraw)\r\n            }\r\n        }\r\n\r\n        startup()\r\n    }, [ref, draw])\r\n\r\n    // TICK\r\n    useEffect(() => {\r\n        if (game.paused || game.ended) return\r\n\r\n        function createNewShape(draw: Svg) {\r\n            const shapes: ShapeClass[] = [ShapeLeftL,ShapeLeftS,ShapeLine,ShapeRightL,ShapeRightS,ShapeSquare,ShapeT]\r\n            const rndShape = shapes[getRandomInt(0,shapes.length-1)]\r\n            const shape = shapeBuilder(draw, rndShape)\r\n            \r\n            const rndX = getRandomInt(-shape.widthStartGap * shape.widthT, configs.canvas.width - shape.realStartWidth - shape.strokeWidth)\r\n            const x = rndX - rndX % shape.widthT\r\n            const y = - Math.floor(shape.rotationShapes[shape.rotation].length - shape.heightStartGap) * shape.heightT - shape.heightStartGap * shape.heightT\r\n\r\n            shape.nested.x(x).y(y)\r\n\r\n            return shape\r\n        }\r\n\r\n        if (draw && tick.available) {\r\n            setTick({ ...tick, available: false })\r\n\r\n            let newShapes: ShapeState[] | null = null\r\n            let newGrid: Grid | null = null\r\n\r\n            let active = shapes.current.find(e => e.active)\r\n            \r\n            if (active) {\r\n                const positions = getPositions(active.shape)\r\n                const collision = checkColission(draw, active.shape, 'down')\r\n                \r\n                // COLLISION\r\n                if (collision) {\r\n                    const ended = positions.some(p => p.y < 0)\r\n\r\n                    if (ended) {\r\n                        audioRef?.pause()\r\n                        setGame({ ...game, paused: false, ended: true })\r\n                        return\r\n                    }\r\n\r\n                    newGrid = cloneDeep(grid.current)\r\n\r\n                    for (let pos of positions) {\r\n                        if (!newGrid[pos.y]) newGrid[pos.y] = []\r\n                        newGrid[pos.y]![pos.x] = pos.pixel\r\n                    }\r\n\r\n                    const index = shapes.current.indexOf(active)\r\n                    \r\n                    newShapes = update(shapes.current, {\r\n                        [index]: {\r\n                            active: { $set: false }\r\n                        }\r\n                    })\r\n\r\n                    active = undefined\r\n                }\r\n            }\r\n\r\n            if (!active) {\r\n                const shape = createNewShape(draw)\r\n\r\n                active = {\r\n                    active: true,\r\n                    shape: shape\r\n                }\r\n\r\n                newShapes = newShapes ? [...newShapes, active] : [...shapes.current, active]\r\n            }\r\n\r\n            active.shape.nested.y(active.shape.nested.y() + configs.pixel.heightT)\r\n            \r\n            fixPosition(active.shape)\r\n\r\n            const fullLines = newGrid?.reduce((acc,val,i) => {\r\n                if (val && val.filter(e => !!e).length === configs.canvas.gridWidth) acc.push(i)\r\n                return acc\r\n            }, [] as number[]).reverse()\r\n            \r\n            if (fullLines) {\r\n                let lineCount = 0\r\n                for (let i of fullLines) {\r\n                    i += lineCount\r\n                    for (let j = 0; j < configs.canvas.gridWidth; j++) {\r\n                        if (newGrid?.[i]?.[j]) {\r\n                            newGrid[i]![j]!.remove()\r\n                            newGrid[i]![j] = undefined\r\n                        }\r\n                    }\r\n\r\n                    for (let j = i - 1; j >= 0; j--) {\r\n                        if (newGrid?.[j]) {\r\n                            newGrid[j]!.forEach(e => { if (e) e.y(e.y() + configs.pixel.heightT) })\r\n                            newGrid[j+1] = newGrid[j]\r\n                            newGrid[j] = undefined\r\n                        }\r\n                    }\r\n\r\n                    lineCount++\r\n                }\r\n\r\n                if (fullLines.length > 0)\r\n                    setGame({ ...game, score: game.score + Math.round(Math.pow(fullLines.length,1.75)) * 100 }) \r\n            }\r\n\r\n            // setState em um unico lugar evita problema de state diferente em closure (https://stackoverflow.com/a/58877875)\r\n            if (newShapes) shapes.current = newShapes\r\n            if (newGrid) grid.current = newGrid\r\n            \r\n            let tickTime = 1000 - (game.score / 125000)\r\n            tickTime = tickTime < 200 ? 200 : tickTime \r\n            \r\n            setTimeout(() => setTick({\r\n                available: true,\r\n                count: tick.count + 1\r\n            }), tickTime)\r\n        }\r\n    }, [tick, game, draw, fixPosition, checkColission, audioRef])\r\n\r\n    // CONTROLS\r\n    const runActive = (run: (shape: BaseShape) => void) => {\r\n        const active = shapes.current.find(e => e.active)\r\n        if (active && !game.paused && !game.ended) run(active.shape)\r\n    }\r\n\r\n    const keyMap = {\r\n        MOVE_UP: 'up',\r\n        MOVE_DOWN: 'down',\r\n        MOVE_LEFT: 'left',\r\n        MOVE_RIGHT: 'right',\r\n        SPACE: 'space'\r\n    }\r\n       \r\n    const handlers = {\r\n        MOVE_UP: (event: any) => {\r\n            runActive(shape => {\r\n                shape.rotate()\r\n                fixPosition(shape)\r\n            })\r\n        },\r\n        MOVE_DOWN: (event: any) => {\r\n            runActive(shape => {\r\n                const y = shape.nested.y()\r\n                const h = shape.heightT\r\n                if (draw && !checkColission(draw, shape, 'down'))\r\n                    shape.nested.y(y + h)\r\n                fixPosition(shape)\r\n            })\r\n        },\r\n        MOVE_LEFT: (event: any) => {\r\n            runActive(shape => {\r\n                const x = shape.nested.x()\r\n                const w = shape.widthT\r\n                const nextPos = x - w\r\n                if (nextPos >= -shape.widthStartGap * shape.widthT) {\r\n                    if (draw && !checkColission(draw, shape, 'left')) {\r\n                        shape.nested.x(nextPos)\r\n                    }\r\n                }\r\n                fixPosition(shape)\r\n            })\r\n        },\r\n        MOVE_RIGHT: (event: any) => {\r\n            runActive(shape => {\r\n                const x = shape.nested.x()\r\n                const w = shape.widthT\r\n                const nextPos = x + w\r\n                if (nextPos + shape.realStartWidth <= configs.canvas.width) {\r\n                    if (draw && !checkColission(draw, shape, 'right')) {\r\n                        shape.nested.x(nextPos)\r\n                    }\r\n                }\r\n                fixPosition(shape)\r\n            })\r\n        },\r\n        SPACE: (event: any) => togglePlay()\r\n    }\r\n\r\n    return (\r\n        <GlobalHotKeys allowChanges={true} keyMap={keyMap} handlers={handlers}>\r\n            <audio ref={ref => audioRef = ref} src={tetrisAudio} autoPlay loop />\r\n            <CanvasWrapper>\r\n                <Canvas ref={ref => setRef(ref)} />\r\n                <CanvasControls>\r\n                    <CanvasScore>{game.score}</CanvasScore>\r\n                    <button onClick={(event: any) => {\r\n                        // event.preventDefault()\r\n                        togglePlay()\r\n                    }}>\r\n                        {game.paused ? <MdPlayArrow /> : <MdPause />}\r\n                    </button>\r\n                    <br/>\r\n                    Ended: {game.ended ? 'YES' : 'NO'}\r\n                </CanvasControls>\r\n            </CanvasWrapper>\r\n        </GlobalHotKeys>\r\n    )\r\n}\r\n\r\nexport default GameCanvas;","import { Svg } from \"@svgdotjs/svg.js\";\r\nimport BaseShape from \"./BaseShape\";\r\n\r\nexport type ShapeClass = new (draw: Svg) => BaseShape\r\n\r\nexport default function shapeBuilder<T extends BaseShape>(draw: Svg, shape: ShapeClass) {\r\n    return (new shape(draw)).build()\r\n}","import React from 'react';\nimport './App.scss';\nimport GameCanvas from './components/GameCanvas/GameCanvas';\n\nconst App: React.FC = () => {\n  return (\n    <GameCanvas />\n  )\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { configure } from 'react-hotkeys';\n\nconfigure({\n    ignoreRepeatedEventsWhenKeyHeldDown: false\n})\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}